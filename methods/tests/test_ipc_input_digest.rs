use std::path::PathBuf;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use risc0_zkvm::{ExecutorEnv, ExternalProver, Prover, ProverOpts, VerifierContext};
use risc0_zkvm::sha::Digestible;

#[test]
fn test_ipc_input_digest() -> anyhow::Result<()> {
    // For example:
    let input: u32 = 15 * u32::pow(2, 27) + 1;

    // Setup environment
    let mut env_builder = ExecutorEnv::builder();

    env_builder
        .write(&input)?;

    // Set any digest as the input label
    // FIXME: The IPC prover fails to capture this
    let label = b"Proven by a hero".digest();
    env_builder.input_digest(label);

    let env = env_builder.build()?;

    // let prover = default_prover();
    let prover = ExternalProver::new("ipc", get_r0vm_path());

    let opts = ProverOpts::fast().with_prove_guest_errors(true);
    let prove_info = prover.prove_with_opts(
        env,
        methods::MY_LABELED_ZK_PROGRAM_ELF,
        &opts)?;

    // extract the receipt.
    let stark_receipt = prove_info.receipt;
    // verify output
    let output: u32 = stark_receipt.journal.decode()?;
    assert_eq!(input, output);

    // Ensures the claim and journal are attested to by the seal
    stark_receipt.verify_integrity_with_context(&VerifierContext::default())?;
    // Manually check the image ID.
    let receipt_claim = stark_receipt.claim()?.value()?;
    assert_eq!(
        receipt_claim.pre.digest(),
        methods::MY_LABELED_ZK_PROGRAM_ID.into()
    );
    // Verify that the input label was used
    let receipt_claim = stark_receipt.claim()?.value()?;
    assert_eq!(receipt_claim.input.digest(), label);

    Ok(())
}

fn get_r0vm_path() -> PathBuf {
    std::env::var("RISC0_SERVER_PATH")
        .unwrap_or("r0vm".to_string())
        .into()
}